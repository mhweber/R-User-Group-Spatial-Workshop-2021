# Geoprocessing
## Lesson Goals

A quick look at a couple typical topological operations (spatial subsetting, spatial joins, dissolve) using `sf`

## Example one
### Spatial Subsetting
Let's look at the bike paths and parks data in the `awra2020spatial` package. A typical spatial question we might ask of our data is 'what trails go through parks in town?' A great feature of `sf` is it supports spatial indexing:
```{r subset, message=FALSE, warning=FALSE, error=FALSE}
library(sf)
library(awra2020spatial)
data(parks)
data(bike_paths)

plot(bike_paths$geoms, col='green', axes=T)
plot(parks$geoms, col='blue', add=T)
paths_in_parks <- bike_paths[parks,]
plot(paths_in_parks$geoms, col='red', lwd = 2, add=T)
title(main='Bike Paths in Parks in Austin')
```

## Example two
### Spatial Join
First we'll use chained operations to select just a couple columns from both bike_paths and parks, and then we'll do a spatial join operation in `sf`.  Note again, when we do a select on just attribute column, the geometry column remains - geometry is sticky in `sf`!
```{r join, message=FALSE, warning=FALSE, error=FALSE}
library(dplyr)
bike_paths <- bike_paths %>% 
  dplyr::select(ROUTE_NAME)
parks <- parks %>% 
  dplyr::select(LOCATION_NAME, ZIPCODE,PARK_TYPE)
parks_bike_paths <- st_join(parks, bike_paths) # st_intersects is the default
glimpse(parks_bike_paths)
```

## Example Three
### Dissolve
We can perform a spatial dissolve in `sf` using `dplyr` `group_by` and `summarize` functions with an `sf` object!
Note that we could pull down `tidycensus` at tract level, but instead we want to look at running a dissolve to get from block group to tract level
```{r dissolve, message=FALSE, warning=FALSE, error=FALSE}
library(ggplot2)
parks$AREA <- st_area(parks)
parks_zip <- parks %>% 
  group_by(ZIPCODE) %>%
  summarise(AREA = sum(AREA)) %>%
  ggplot() + geom_sf(aes(fill=(ZIPCODE))) +
  ggtitle("Austin Parks by Zip Code") + 
  theme_bw()
parks_zip
```

## Example Four
### Spatial Overlap
Here's a fun example using material posted by Nicholas Tierney [here](https://www.njtierney.com/post/2021/08/21/how-much-one-shapefile-overlaps-another/) that he put together based on [this Stack Overflow discussion](https://gis.stackexchange.com/questions/362466/calculate-percentage-overlap-of-2-sets-of-polygons-in-r).

First we'll extract the Portland Oregon metropolitan area using the `tidycensus` and `tigris` packages
```{r overlap, message=FALSE, warning=FALSE, error=FALSE}
library(ggplot2)
library(tidycensus)
library(tidyverse)
library(tigris)

tracts <- get_acs(geography = "tract", variables = "DP04_0134", 
                state = "OR", geometry = TRUE, progress_bar = FALSE)

pdx <- core_based_statistical_areas(cb = TRUE, progress_bar = FALSE) %>%
  filter(GEOID == "38900")
ggplot() + 
  geom_sf(data = pdx,
          fill = "forestgreen") 
```

#### Next we'll create a dummy spatial polygon file to compare area with using the `rmapshaper` package to simplify the border of the PDX metropolitan polygon
```{r overlap2, message=FALSE, warning=FALSE, error=FALSE}
library(rmapshaper) 
pdx_simplified <- pdx %>% 
  ms_simplify(keep = 0.01)
```

#### Then we can overlay polygons in ggplot to see how similar they are, showing the original census PDX metropolitan area in green, and new simplified polygon in red
```{r overlap3, message=FALSE, warning=FALSE, error=FALSE}
ggplot() + 
  geom_sf(data = pdx,
          fill = "forestgreen", alpha = 0.5) + 
  geom_sf(data = pdx_simplified, 
          fill = "firebrick",
          alpha = 0.5)
```

#### Now that we have an original and simplified polygon to compare, the process we want to use is:

- Calculate original metro area polygon area
- Calculate the intersection of these two areas - original and simplified (st_intersection)
- Calculate that area (st_area)
- Then only keep the relevant data again

We'll run the steps then combine into a function
```{r overlap5, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
original_area <- pdx %>% 
    mutate(original_area = st_area(.)) %>% 
    select(NAME, original_area) %>% 
    st_drop_geometry()

intersection_area <- st_intersection(pdx, pdx_simplified) %>% 
    mutate(intersect_area = st_area(.)) %>% 
    select(NAME, intersect_area) %>% 
    st_drop_geometry()
```

#### Exercise
This step should have given you an error -THIS IS VERY COMMON WORKING WITH SPATIAL DATA IN R AND USING `sf`.

##### Solution
```{r overlap6, message=FALSE, warning=FALSE, error=FALSE}
pdx_simplified <- st_make_valid(pdx_simplified)
pdx <- st_make_valid(pdx)

original_area <- pdx %>% 
    mutate(original_area = st_area(.)) %>% 
    select(NAME, original_area) %>% 
    st_drop_geometry()
    
intersection_area <- st_intersection(pdx, pdx_simplified) %>% 
    mutate(intersect_area = st_area(.)) %>% 
    select(NAME, intersect_area) %>% 
    st_drop_geometry()

# show the area of intersection
intersection_area

# show the proportion of overlap
intersection_area %>% 
    left_join(original_area, 
              by = "NAME") %>% 
    mutate(orig = as.numeric(original_area),
           new = as.numeric(intersect_area),
           proportion = (new / orig) * 100)
```

#### Exercise
Why did I use `as.numeric` in the `mutate` statement above?
 
##### Solution
Because `sf` will store area for features using `units` - which is convenient and forces you to be up front about units used, but you can't do calculations with attributes stored as units - have to convert them to numeric 

#### All steps rolled into a function
```{r overlap7, message=FALSE, warning=FALSE, error=FALSE}


calculate_spatial_overlap <- function(shape_new,
                                      shape_old,
                                      shared_column_name) {
  
  
  intersection_area <- st_intersection(shape_new, shape_old) %>% 
    mutate(intersect_area = st_area(.)) %>% 
    select(shared_column_name, intersect_area) %>% 
    st_drop_geometry()
  
  # Create a fresh area variable
  shape_old_areas <- shape_old %>% 
    mutate(original_area = st_area(.)) %>% 
    select(original_area, shared_column_name) %>% 
    st_drop_geometry()
  
  intersection_area %>% 
    left_join(shape_old_areas, 
              by = shared_column_name) %>% 
    mutate(orig = as.numeric(original_area),
           new = as.numeric(intersect_area),
           proportion = (new / orig) * 100)
  
}

calculate_spatial_overlap(pdx, pdx_simplified, shared_column_name='NAME')

```