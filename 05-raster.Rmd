# Raster data

Support for gridded data in R in recent year has been best implemented with the `raster` package by Robert Hijmans. The `raster` package allows you to:

* read and write almost any commonly used raster data format using `rgdal`
* perform typical raster processing operations such as resampling, projecting, filtering, raster math, etc.
* work with files on disk that are too big to read into memory in R
* run operations quickly since the package relies on back-end C code 

The [terra](https://github.com/rspatial/terra) package is the replacement for the `raster` package and has now superceeded it and we will largely focus on `terra` here. Examples here draw from both [Spatial Data Science with R and terra](https://rspatial.org/terra/index.html) and [An introduction to terra in Geocomputation with R](https://geocompr.robinlovelace.net/spatial-class.html#raster-data).  Use help("terra-package") in the console for full list of available `terra` functions and comparison to / changes from `raster`.

Raster representation is currently in flux a bit in R now with three choices of packages - `raster` and now `terra` which we've mentioned, as well as [stars](https://r-spatial.github.io/stars/index.html) (spatiotemporal tidy arrays with R).

To familiarize ourselves with the `terra` package, let's create an empty `SpatRaster` object - in order to do this we have to:
* define the matrix (rows and columns) 
* define the spatial bounding box

Note that typically we would be reading raster data in from a file rather than creating a raster from scratch. Run through code steps below to familiarize yourself with constructing a `RasterLayer` from scratch - you can provide a different bounding box for an area of your choosing.

```{r raster-layer, message=FALSE, warning=FALSE, error=FALSE}
library(terra)
myrast <- rast(ncol=10, nrow = 10, xmax=-116,xmin=-126,ymin=42,ymax=46)
# str(myrast)
isS4(myrast)
```

`terra` uses an `S4` slot structure with a `SpatRaster` object. Simply typing the name of the `SpatRaster` gives a summary of the object at the console.
```{r raster-layer2, message=FALSE, warning=FALSE, error=FALSE}
myrast
```

`terra` has dedicated functions addressing each of these components: 
  - `dim(my_rast)` returns the number of rows, columns and layers
  - `ncell()` returns the number of cells (pixels)
  - `res()` returns the spatial resolution
  - `ext()` returns spatial extent
  - `crs()` returns the coordinate reference system

### Challenge {.challenge}
Exploring raster objects 

1. what is the minimal data required to define a `SpatRaster`? 
2. What is the CRS of our `SpatRaster`? 
3. How do we pull out just the CRS for our r `SpatRaster`? 
4. Building on this, what is the code to pull out just our xmin value in our extent, or bounding box?

#### Answer {.solution} 

1. number columns, number rows, and extent - the `raster` package however will fill in defaults if values aren't provided
```{r raster-emptyexample, message=FALSE, warning=FALSE, error=FALSE}
t <- rast()
t
```

2. We didn't provide one - `terra` uses default `crs` of WGS84 if you don't provide a `crs`

3. 
```{r message=FALSE, warning=FALSE, error=FALSE}
crs(myrast)
```

4. 
```{r message=FALSE, warning=FALSE, error=FALSE}
ext(myrast)
# just grab xmin
ext(myrast)[1]
# we can see that extent is actually a c++ object in the ptr slot of our spatRaster object
# str(myrast)
# names(myrast@ptr)
myrast@ptr$extent
```

### Manipulating `raster` objects
So far we just have a container with no values (try plotting what we have so far) - let's provide values to the cells using the runif function to derive random values from the uniform distribution
```{r runif, message=FALSE, warning=FALSE, error=FALSE}
#show we have no values
hasValues(myrast)
values(myrast) <- runif(n=ncell(myrast))
myrast
```

An important point to make here is that objects in the `terra` package (and previously in `raster`) can be either in memory or on disk - note the value for our `spatRaster` r of 'source'.  If this were a large raster on disk, the value would be the path to the file on disk.

```{r inmemory, message=FALSE, warning=FALSE, error=FALSE}
myrast@ptr$inMemory
hasValues(myrast)
myrast@ptr$nlyr() # we just have one layer in our object
# or
nlyr(myrast)
```

`terra` also provides plot method for it's classes:
```{r plot raster, message=FALSE, warning=FALSE, error=FALSE}
plot(myrast)
```

We can also overwrite the cell values for our raster:
```{r new_values_raster, message=FALSE, warning=FALSE, error=FALSE}
values(myrast) <- 1:ncell(myrast)
values(myrast)
```

You can access raster values via direct indexing or line, column indexing - take a minute to see how this works using raster r we just created - the syntax is:
```r
myrast[i]
myrast[line, column]
```
How is `terra` data storage unlike a `matrix` in R?  You can create a `matrix` with same dimensions and values and compare if you want:
```{r matrix_raster, message=FALSE, warning=FALSE, error=FALSE}
m <- matrix (1:100, nrow=10, ncol=10)
m[1,10]
myrast[1,10]
myrast[10]
```

### Reading existing rasters on disk
```{r single_raster, message=FALSE, warning=FALSE, error=FALSE}
raster_filepath = system.file("raster/srtm.tif", package = "spDataLarge")
my_rast = rast(raster_filepath)
nlyr(my_rast)
plot(my_rast)
```

### Multiband rasters
The `spatRaster` object in `terra` can hold multiple layers (similar to `RasterBrick` and `RasterStack` which were two additional classes in the `raster` package).  These layers correspond to multispectral satellite imagery or a time-series raster.

```{r multiband, message=FALSE, warning=FALSE, error=FALSE}
landsat = system.file("raster/landsat.tif", package = "spDataLarge")
landsat = rast(landsat)
landsat
plot(landsat)
```

### Plotting rasters and vectors with tmap
Bring in boundary and elevation of Crater Lake NP (datasets in Rspatialworkshop package) and plot with tmap
```{r tmap_raster_plot, message=FALSE, warning=FALSE, error=FALSE}
library(Rspatialworkshop)
library(terra)
library(tmap)
data(CraterLake)
raster_filepath <- system.file("extdata", "elevation.tif", package = "Rspatialworkshop")
elevation <- rast(raster_filepath)

map_crlk <- tm_shape(CraterLake) + tm_polygons(lwd = 2)
map_crlkel = map_crlk +
  tm_shape(elevation) + tm_raster(alpha = 0.7,palette = terrain.colors(12)) + tm_layout(legend.position = c("left","bottom"),
          legend.width = 1)

map_crlkel
```