[["raster-data-1.html", "Chapter 5 Raster data 5.1 Raster data with terra 5.2 Raster data with stars", " Chapter 5 Raster data 5.1 Raster data with terra Support for gridded data in R in recent year has been best implemented with the raster package by Robert Hijmans. The raster package allows you to: read and write almost any commonly used raster data format using rgdal perform typical raster processing operations such as resampling, projecting, filtering, raster math, etc. work with files on disk that are too big to read into memory in R run operations quickly since the package relies on back-end C code The terra package is the replacement for the raster package and has now superceeded it and we will largely focus on terra here. Examples here draw from both Spatial Data Science with R and terra and An introduction to terra in Geocomputation with R. Use help(terra-package) in the console for full list of available terra functions and comparison to / changes from raster. Raster representation is currently in flux a bit in R now with three choices of packages - raster and now terra which weve mentioned, as well as stars (spatiotemporal tidy arrays with R). To familiarize ourselves with the terra package, lets create an empty SpatRaster object - in order to do this we have to: * define the matrix (rows and columns) * define the spatial bounding box Note that typically we would be reading raster data in from a file rather than creating a raster from scratch. Run through code steps below to familiarize yourself with constructing a RasterLayer from scratch - you can provide a different bounding box for an area of your choosing. library(terra) myrast &lt;- rast(ncol=10, nrow = 10, xmax=-116,xmin=-126,ymin=42,ymax=46) # str(myrast) isS4(myrast) ## [1] TRUE terra uses an S4 slot structure with a SpatRaster object. Simply typing the name of the SpatRaster gives a summary of the object at the console. myrast ## class : SpatRaster ## dimensions : 10, 10, 1 (nrow, ncol, nlyr) ## resolution : 1, 0.4 (x, y) ## extent : -126, -116, 42, 46 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=longlat +datum=WGS84 +no_defs terra has dedicated functions addressing each of these components: - dim(my_rast) returns the number of rows, columns and layers - ncell() returns the number of cells (pixels) - res() returns the spatial resolution - ext() returns spatial extent - crs() returns the coordinate reference system 5.1.1 Exercise Exploring raster objects what is the minimal data required to define a SpatRaster? What is the CRS of our SpatRaster? How do we pull out just the CRS for our r SpatRaster? Building on this, what is the code to pull out just our xmin value in our extent, or bounding box? 5.1.2 Solution number columns, number rows, and extent - the raster package however will fill in defaults if values arent provided t &lt;- rast() t ## class : SpatRaster ## dimensions : 180, 360, 1 (nrow, ncol, nlyr) ## resolution : 1, 1 (x, y) ## extent : -180, 180, -90, 90 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=longlat +datum=WGS84 +no_defs We didnt provide one - terra uses default crs of WGS84 if you dont provide a crs crs(myrast) ## [1] &quot;GEOGCRS[\\&quot;WGS 84\\&quot;,\\n DATUM[\\&quot;World Geodetic System 1984\\&quot;,\\n ELLIPSOID[\\&quot;WGS 84\\&quot;,6378137,298.257223563,\\n LENGTHUNIT[\\&quot;metre\\&quot;,1]],\\n ID[\\&quot;EPSG\\&quot;,6326]],\\n PRIMEM[\\&quot;Greenwich\\&quot;,0,\\n ANGLEUNIT[\\&quot;degree\\&quot;,0.0174532925199433],\\n ID[\\&quot;EPSG\\&quot;,8901]],\\n CS[ellipsoidal,2],\\n AXIS[\\&quot;longitude\\&quot;,east,\\n ORDER[1],\\n ANGLEUNIT[\\&quot;degree\\&quot;,0.0174532925199433,\\n ID[\\&quot;EPSG\\&quot;,9122]]],\\n AXIS[\\&quot;latitude\\&quot;,north,\\n ORDER[2],\\n ANGLEUNIT[\\&quot;degree\\&quot;,0.0174532925199433,\\n ID[\\&quot;EPSG\\&quot;,9122]]]]&quot; ext(myrast) ## SpatExtent : -126, -116, 42, 46 (xmin, xmax, ymin, ymax) # just grab xmin ext(myrast)[1] ## xmin ## -126 # we can see that extent is actually a c++ object in the ptr slot of our spatRaster object # str(myrast) # names(myrast@ptr) myrast@ptr$extent ## C++ object &lt;000000001954fb90&gt; of class &#39;SpatExtent&#39; &lt;000000001930a950&gt; 5.1.3 Manipulating raster objects So far we just have a container with no values (try plotting what we have so far) - lets provide values to the cells using the runif function to derive random values from the uniform distribution #show we have no values hasValues(myrast) ## [1] FALSE values(myrast) &lt;- runif(n=ncell(myrast)) myrast ## class : SpatRaster ## dimensions : 10, 10, 1 (nrow, ncol, nlyr) ## resolution : 1, 0.4 (x, y) ## extent : -126, -116, 42, 46 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=longlat +datum=WGS84 +no_defs ## source : memory ## name : lyr.1 ## min value : 0.001735749 ## max value : 0.9536106 An important point to make here is that objects in the terra package (and previously in raster) can be either in memory or on disk - note the value for our spatRaster r of source. If this were a large raster on disk, the value would be the path to the file on disk. myrast@ptr$inMemory ## [1] TRUE hasValues(myrast) ## [1] TRUE myrast@ptr$nlyr() # we just have one layer in our object ## [1] 1 # or nlyr(myrast) ## [1] 1 terra also provides plot method for its classes: plot(myrast) We can also overwrite the cell values for our raster: values(myrast) &lt;- 1:ncell(myrast) values(myrast) ## lyr.1 ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 ## [6,] 6 ## [7,] 7 ## [8,] 8 ## [9,] 9 ## [10,] 10 ## [11,] 11 ## [12,] 12 ## [13,] 13 ## [14,] 14 ## [15,] 15 ## [16,] 16 ## [17,] 17 ## [18,] 18 ## [19,] 19 ## [20,] 20 ## [21,] 21 ## [22,] 22 ## [23,] 23 ## [24,] 24 ## [25,] 25 ## [26,] 26 ## [27,] 27 ## [28,] 28 ## [29,] 29 ## [30,] 30 ## [31,] 31 ## [32,] 32 ## [33,] 33 ## [34,] 34 ## [35,] 35 ## [36,] 36 ## [37,] 37 ## [38,] 38 ## [39,] 39 ## [40,] 40 ## [41,] 41 ## [42,] 42 ## [43,] 43 ## [44,] 44 ## [45,] 45 ## [46,] 46 ## [47,] 47 ## [48,] 48 ## [49,] 49 ## [50,] 50 ## [51,] 51 ## [52,] 52 ## [53,] 53 ## [54,] 54 ## [55,] 55 ## [56,] 56 ## [57,] 57 ## [58,] 58 ## [59,] 59 ## [60,] 60 ## [61,] 61 ## [62,] 62 ## [63,] 63 ## [64,] 64 ## [65,] 65 ## [66,] 66 ## [67,] 67 ## [68,] 68 ## [69,] 69 ## [70,] 70 ## [71,] 71 ## [72,] 72 ## [73,] 73 ## [74,] 74 ## [75,] 75 ## [76,] 76 ## [77,] 77 ## [78,] 78 ## [79,] 79 ## [80,] 80 ## [81,] 81 ## [82,] 82 ## [83,] 83 ## [84,] 84 ## [85,] 85 ## [86,] 86 ## [87,] 87 ## [88,] 88 ## [89,] 89 ## [90,] 90 ## [91,] 91 ## [92,] 92 ## [93,] 93 ## [94,] 94 ## [95,] 95 ## [96,] 96 ## [97,] 97 ## [98,] 98 ## [99,] 99 ## [100,] 100 You can access raster values via direct indexing or line, column indexing - take a minute to see how this works using raster r we just created - the syntax is: myrast[i] myrast[line, column] How is terra data storage unlike a matrix in R? You can create a matrix with same dimensions and values and compare if you want: m &lt;- matrix (1:100, nrow=10, ncol=10) m[1,10] ## [1] 91 myrast[1,10] ## lyr.1 ## 1 10 myrast[10] ## lyr.1 ## 1 10 5.1.4 Reading existing rasters on disk raster_filepath = system.file(&quot;raster/srtm.tif&quot;, package = &quot;spDataLarge&quot;) my_rast = rast(raster_filepath) nlyr(my_rast) ## [1] 1 plot(my_rast) 5.1.5 Multiband rasters The spatRaster object in terra can hold multiple layers (similar to RasterBrick and RasterStack which were two additional classes in the raster package). These layers correspond to multispectral satellite imagery or a time-series raster. landsat = system.file(&quot;raster/landsat.tif&quot;, package = &quot;spDataLarge&quot;) landsat = rast(landsat) landsat ## class : SpatRaster ## dimensions : 1428, 1128, 4 (nrow, ncol, nlyr) ## resolution : 30, 30 (x, y) ## extent : 301905, 335745, 4111245, 4154085 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=utm +zone=12 +datum=WGS84 +units=m +no_defs ## source : landsat.tif ## names : lan_1, lan_2, lan_3, lan_4 ## min values : 7550, 6404, 5678, 5252 ## max values : 19071, 22051, 25780, 31961 plot(landsat) 5.1.6 Plotting rasters and vectors with tmap Bring in boundary and elevation of Crater Lake NP (datasets in Rspatialworkshop package) and plot with tmap library(Rspatialworkshop) library(terra) library(tmap) data(CraterLake) raster_filepath &lt;- system.file(&quot;extdata&quot;, &quot;elevation.tif&quot;, package = &quot;Rspatialworkshop&quot;) elevation &lt;- rast(raster_filepath) map_crlk &lt;- tm_shape(CraterLake) + tm_polygons(lwd = 2) map_crlkel = map_crlk + tm_shape(elevation) + tm_raster(alpha = 0.7,palette = terrain.colors(12)) + tm_layout(legend.position = c(&quot;left&quot;,&quot;bottom&quot;), legend.width = 1) map_crlkel 5.2 Raster data with stars stars works with and stands for spatio-temporal arrays and can deal with more complex data types than either raster or terra such as rotated grids. It should be said though that terra does have improved functionality for using multilayer rasters than raster did. stars integrates with sf and many sf functions have methods for stars objects (i.e. st_bbox and st_transform) - this makes sense since they are both written by Edzer Pebesma. terra unfortunately has poor / no integration with sf - this is a big issue for me personally and I will likely look to stars long-term for my raster processing. 5.2.1 Read a satellite image Basic example shown in stars vignette - using the 30m bands of a Landsat-7 image that comes with the stars package: library(stars) tif = system.file(&quot;tif/L7_ETMs.tif&quot;, package = &quot;stars&quot;) ls7 = read_stars(tif) plot(ls7, axes = TRUE) ## downsample set to c(0,0,1) ls7 (landsat7) is an object with 3 dimensions (x,y and band) and 1 attribute ls7 ## stars object with 3 dimensions and 1 attribute ## attribute(s): ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## L7_ETMs.tif 1 54 69 68.91242 86 255 ## dimension(s): ## from to offset delta refsys point values x/y ## x 1 349 288776 28.5 UTM Zone 25, Southern Hem... FALSE NULL [x] ## y 1 352 9120761 -28.5 UTM Zone 25, Southern Hem... FALSE NULL [y] ## band 1 6 NA NA NA NA NULL Note when we plotted above that the plot method with stars uses histogram stretching across all bands - we can also do stretching for each band indivially: plot(ls7, join_zlim = FALSE) ## downsample set to c(0,0,1) stars uses tidyverse methods spatio-temporal arrays - an example of this is pulling out one band of an image using slice ls7 %&gt;% dplyr::slice(band, 6) -&gt; band6 band6 ## stars object with 2 dimensions and 1 attribute ## attribute(s): ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## L7_ETMs.tif 1 32 60 59.97521 88 255 ## dimension(s): ## from to offset delta refsys point values x/y ## x 1 349 288776 28.5 UTM Zone 25, Southern Hem... FALSE NULL [x] ## y 1 352 9120761 -28.5 UTM Zone 25, Southern Hem... FALSE NULL [y] This gives us a lower-dimensional array of just band 6 from the Landsat7 image. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
