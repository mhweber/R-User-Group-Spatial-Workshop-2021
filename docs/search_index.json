[["index.html", "Fundamentals of Spatial Analysis in R Chapter 1 Introduction 1.1 Workshop Packages and Data 1.2 Overview 1.3 R Basics Review 1.4 Spatial Data in R 1.5 Quick examples", " Fundamentals of Spatial Analysis in R Marc Weber 2021-08-23 Chapter 1 Introduction Figure 1.1: A bit about me Workshop agenda Intro and quick review of basic R objects and methods Getting spatial data into R Understanding vector and raster data in R and some example workflows Understanding coordinate reference systems (CRS) Learning ways to map and visualize spatial data Along the way: overview of select tidyverse packages and syntax i.e. ggplot2, dplyr, readr, tidyr, the pipe operator %&gt;% Working with vector and raster data in R If this is all new, dont sweat it - google things, well answer questions as we go This portion of workshop there is no expectation of experience with spatial analysis in R - if you already have some experience, you are sure to pick up new tricks - if you dont, well cover the basics We have a limited time to cover a very broad topic, so Ill move quickly - ask questions as they come up, but if you get lost on steps well have time for discussion at the end and material will be available to peruse at your own speed later. 1.1 Workshop Packages and Data Packages you need installed sf raster ggplot2 stars tmap tmaptools dplyr devtools palmerpenguins tigris tibble rgdal leaflet mapview awra2020spatial - data for this workshop contained in package Downloading content via Github Using RMarkdown and RStudio 1.2 Overview Figure 1.2: History of R What is R and why should we use R for spatial analysis? Lets break that into two questions - first, what is R and why should we use it? A language and environment for statistical computing and graphics R is lightweight, free, open-source and cross-platform Works with contributed packages - currently 15,362 - extensibility Automation and recording of workflow (reproducibility) Optimized work flow - data manipulation, analysis and visualization all in one place R does not alter underlying data - manipulation and visualization in memory R is great for repetetive graphics Second, why use R for spatial, or GIS, work? Spatial and statistical analysis in one environment Leverage statistical power of R (i.e. modeling spatial data, data visualization, statistical exploration) Can handle vector and raster data, as well as work with spatial databases and pretty much any data format spatial data comes in Rs GIS capabilities growing rapidly right now - new packages added monthly - currently about 200 spatial packages (depending on how you categorize) Some drawbacks to using R for GIS work R not as good for interactive use as desktop GIS applications like ArcGIS or QGIS (i.e. editing features, panning, zooming, and analysis on selected subsets of features) Explicit coordinate system handling by the user, no on-the-fly projection support In memory analysis does not scale well with large GIS vector and tabular data Steep learning curve Up to you to find packages to do what you need - help not always great 1.3 R Basics Review getwd() Which should return something like: [1] &quot;/home/marc/GitProjects/AWRA_GIS_R_Workshop&quot; To see what is in the directory: dir() ## [1] &quot;_after_body.html&quot; ## [2] &quot;_book&quot; ## [3] &quot;_bookdown.yml&quot; ## [4] &quot;_bookdown_files&quot; ## [5] &quot;_output.yml&quot; ## [6] &quot;02-importing.Rmd&quot; ## [7] &quot;03-crs.Rmd&quot; ## [8] &quot;04-vector.Rmd&quot; ## [9] &quot;05-raster.Rmd&quot; ## [10] &quot;06-geoprocessing.Rmd&quot; ## [11] &quot;07-visualization.Rmd&quot; ## [12] &quot;08-references.Rmd&quot; ## [13] &quot;book.bib&quot; ## [14] &quot;citylim_2017.CPG&quot; ## [15] &quot;citylim_2017.dbf&quot; ## [16] &quot;citylim_2017.json&quot; ## [17] &quot;citylim_2017.prj&quot; ## [18] &quot;citylim_2017.shp&quot; ## [19] &quot;citylim_2017.shp.xml&quot; ## [20] &quot;citylim_2017.shx&quot; ## [21] &quot;citylim_2017.xml&quot; ## [22] &quot;citylim_2017.zip&quot; ## [23] &quot;css&quot; ## [24] &quot;docs&quot; ## [25] &quot;gadm36_USA_2_sp.rds&quot; ## [26] &quot;images&quot; ## [27] &quot;index.Rmd&quot; ## [28] &quot;js&quot; ## [29] &quot;libs&quot; ## [30] &quot;OregonStateParks.zip&quot; ## [31] &quot;OregonStateParks_20181010.gdb&quot; ## [32] &quot;packages.bib&quot; ## [33] &quot;preamble.tex&quot; ## [34] &quot;R-User-Group-Spatial-Workshop-2021.Rmd&quot; ## [35] &quot;R-User-Group-Spatial-Workshop-2021.Rproj&quot; ## [36] &quot;R-User-Group-Spatial-Workshop-2021_files&quot; ## [37] &quot;README.md&quot; ## [38] &quot;readme.txt&quot; ## [39] &quot;srtm_12_04.hdr&quot; ## [40] &quot;srtm_12_04.tfw&quot; ## [41] &quot;srtm_12_04.tif&quot; ## [42] &quot;state_county_boundary.zip&quot; ## [43] &quot;timestamps&quot; To establish a different directory: setwd(&quot;/home/marc/GitProjects&quot;) 1.3.0.1 Terminology: data structures R is an interpreted language (access through a command-line interpreter) with a number of data structures (vectors, matrices, arrays, data frames, lists) and extensible objects (regression models, time-series, geospatial coordinates) and supports procedural programming with functions. To learn about objects, become friends with the built-in class and str functions. Lets explore a new dataset - palmerpenguins - recently developed by Allison Horst as an alternative to the old R standby iris dataset: library(palmerpenguins) class(penguins) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; str(penguins) ## tibble [344 x 8] (S3: tbl_df/tbl/data.frame) ## $ species : Factor w/ 3 levels &quot;Adelie&quot;,&quot;Chinstrap&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ island : Factor w/ 3 levels &quot;Biscoe&quot;,&quot;Dream&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ bill_length_mm : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ... ## $ bill_depth_mm : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ... ## $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ... ## $ body_mass_g : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ... ## $ sex : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2 1 1 NA 1 2 1 2 NA NA ... ## $ year : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ... penguins is a tibble, which is a new tidyverse spin on data frames, and was created as a new alternative to the iris data set that has been used extensively for beginning tutorials on learning R. Data frames consist of rows of observations on columns of values for variables of interest - they are one of the fundamental and most important data structures in R. tibbles make a few improvements / changes to data frames such as: Never converting strings to factors Never creating row names Updated print method that only shows first 10 rows, just the columns that fit on the screen, and the type of each column (just as we get using str) We can easily convert objects from tibble to data frame and vice versa: library(tibble) penguins &lt;- as.data.frame(penguins) penguins &lt;- as_tibble(penguins) But as we see in the result of str(penguins) above, following the information that penguins is a tibble with 344 observations of 8 variables, we get information on each of the variables, in this case that 2 are numeric, 2 are integers, and 3 are factors - factors encode categorical variables - and str gives us the number of levels in each factor. First off, R has several main data types: logical integer double complex character raw list NULL closure (function) special builtin (basic functions and operators) environment S4 (some S4 objects) others you wont run into at user level We can ask what data type something is using typeof: typeof(penguins) ## [1] &quot;list&quot; typeof(penguins$bill_length_mm) ## [1] &quot;double&quot; typeof(penguins$species) ## [1] &quot;integer&quot; We see a couple interesting things here - penguins, which we just said is a tibble, is a data type of list. bill_length_mm is data type double, and in str(penguins) we saw it was numeric - that makes sense - but we see that species is data type integer, and in str(penguins) we were told this variable was a factor with three levels. Whats going on here? First off, class refers to the abstract type of an object in R, whereas typeof or mode refer to how an object is stored in memory. So penguins is an object of class tibble, but it is stored in memory as a list (i.e. each column is an item in a list). Note that this allows tibbles and data frames to have columns of different classes, whereas a matrix needs to be all of the same mode. For our species column, we see its mode is numeric, its typeof is integer, and its class is factor. Nominal variables in R are treated as a vector of integers 1:k, where k is the number of unique values of that nominal variable and a mapping of the character strings to these integer values. This allows us to quickly see see all the unique values of a particular nominal variable or quickly re-asign a level of a nominal variable to a new value - remember, everything in R is in memory, so dont worry about tweaking the data! levels(penguins$species) ## [1] &quot;Adelie&quot; &quot;Chinstrap&quot; &quot;Gentoo&quot; levels(penguins$species)[1] &lt;- &#39;adeliae&#39; See if you can explain how that re-asignment we just did worked. To access particular columns in a tibble or data frame, as we saw above, we use the $ operator. We can see the value of species for each observation in penguins as well as listing of all levels of the variable by running: penguins$species ## [1] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [8] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [15] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [22] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [29] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [36] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [43] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [50] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [57] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [64] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [71] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [78] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [85] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [92] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [99] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [106] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [113] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [120] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [127] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [134] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [141] adeliae adeliae adeliae adeliae adeliae adeliae adeliae ## [148] adeliae adeliae adeliae adeliae adeliae Gentoo Gentoo ## [155] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [162] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [169] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [176] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [183] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [190] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [197] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [204] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [211] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [218] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [225] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [232] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [239] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [246] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [253] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [260] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [267] Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo Gentoo ## [274] Gentoo Gentoo Gentoo Chinstrap Chinstrap Chinstrap Chinstrap ## [281] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap ## [288] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap ## [295] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap ## [302] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap ## [309] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap ## [316] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap ## [323] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap ## [330] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap ## [337] Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap Chinstrap ## [344] Chinstrap ## Levels: adeliae Chinstrap Gentoo To access particular columns or rows of a data frame, we use indexing: penguins[1,3] # the 1st row and the 3rd column ## # A tibble: 1 x 1 ## bill_length_mm ## &lt;dbl&gt; ## 1 39.1 penguins[4,1] # the 4th row and the 1st column ## # A tibble: 1 x 1 ## species ## &lt;fct&gt; ## 1 adeliae A handy function is names, which you can use to get or to set data frame variable names: names(penguins) ## [1] &quot;species&quot; &quot;island&quot; &quot;bill_length_mm&quot; ## [4] &quot;bill_depth_mm&quot; &quot;flipper_length_mm&quot; &quot;body_mass_g&quot; ## [7] &quot;sex&quot; &quot;year&quot; names(penguins)[3] &lt;- &#39;Bill Length&#39; Explain what this last line did A little example of tidy evaluation and piping to do the same thing - well go into more: penguins &lt;- penguins %&gt;% dplyr::rename(&#39;Bill_Length&#39;=&#39;Bill Length&#39;) # check it names(penguins) ## [1] &quot;species&quot; &quot;island&quot; &quot;Bill_Length&quot; ## [4] &quot;bill_depth_mm&quot; &quot;flipper_length_mm&quot; &quot;body_mass_g&quot; ## [7] &quot;sex&quot; &quot;year&quot; 1.3.0.2 Review of Classes and Methods Class: object types class(): gives the class type typeof(): information on how the object is stored str(): how the object is structured Method: generic functions print() plot() summary() 1.4 Spatial Data in R We can represent spatial data as discrete locations (points, lines or polygons) or as a grid of values rendered on a map as pixels. We typically represent the former type of data (discrete locations) as vector data, with an associated geometry or shape, and some attributes with information about the locations. Examples are: state boundaries with state name and population rivers with their flow volume and names polygons of watersheds with their names and associated landscape information We represent the latter type of data (a grid of values as pixels) with rasters. Rasters can be continous (i.e. elevation, precipitation, atmospheric deposition) or they can be categorical (i.e. land use, soil type) - they can also be image based rasters, and they can be single band or multi-band. Figure 1.3: Raster Data We will delve into working with each of these types of data in their own sections, but lets go over how these spatial data types are handled in R briefly. Basic data structures in R can represent spatial data - all we need is some vectors with location and attribute information - below we generate cites with population, add a polygon, and make a map with a legend - take a minute to run this code in your own R session and make sure you understand what each line is doing. cities &lt;- c(&#39;Ashland&#39;,&#39;Corvallis&#39;,&#39;Bend&#39;,&#39;Portland&#39;,&#39;Newport&#39;) longitude &lt;- c(-122.699, -123.275, -121.313, -122.670, -124.054) latitude &lt;- c(42.189, 44.57, 44.061, 45.523, 44.652) population &lt;- c(20062,50297,61362,537557,9603) locs &lt;- cbind(longitude, latitude) plot(locs, cex=sqrt(population*.0002), pch=20, col=&#39;red&#39;, main=&#39;Population&#39;, xlim = c(-124,-120.5), ylim = c(42, 46)) text(locs, cities, pos=4) # Add a legend breaks &lt;- c(20000, 50000, 60000, 100000) options(scipen=3) legend(&quot;topright&quot;, legend=breaks, pch=20, pt.cex=1+breaks/20000, col=&#39;red&#39;, bg=&#39;gray&#39;) # Add polygon lon &lt;- c(-123.5, -123.5, -122.5, -122.670, -123) lat &lt;- c(43, 45.5, 44, 43, 43) x &lt;- cbind(lon, lat) polygon(x, border=&#39;blue&#39;) lines(x, lwd=3, col=&#39;red&#39;) points(x, cex=2, pch=20) We can see in this toy example that numeric vectors can represent locations in R for simple mapping. Points just need to be a pair of numbers in cartesian space, and lines and polygons are just a number of these points (note that polygons are closed by having their first point coincide with last point which the polygon function in base R graphics takes care of). What about raster data? A raster in essence is simply a matrix of values for raster cells library(&#39;plot.matrix&#39;) # numeric matrix x &lt;- matrix(runif(35), ncol=5) # create a numeric matrix object class(x) ## [1] &quot;matrix&quot; &quot;array&quot; #&gt; [1] &quot;matrix&quot; par(mar=c(5.1, 4.1, 4.1, 4.1)) # adapt margins plot(x) We have a raster of cell values in columnns and rows - but what is lacking? You can do simple things with these spatial representations using basic R structures, but it breaks down quickly if you want to ask any spatial questions - for instance using the first example above, how would we figure out the nearest city to Corvallis? Or imagine the polygon is a county and we wanted to know what cities are within the county? Or how would we superimpose our cities on our raster cells? Or extract the value of a cell at the location of a city? 1.4.1 Challenge What information do we need to properly define spatial vector data and perform spatial operations? 1.4.2 Answer A coordinate reference system (CRS) A bounding box or extent Methods for storing and accessing spatial attributes of data ? 1.4.3 R Spatial Package Landscape 1.4.4 How did we make this figure? Look at answer below, run code in your own code editor, see if it makes sense and ask questions 1.4.5 Answer # devtools::install_github(&quot;metacran/cranlogs&quot;) library(cranlogs, quietly = T) library(ggplot2, quietly = T) library(lubridate, quietly = T) library(dplyr, quietly = T) options(scipen=3) stats &lt;- cran_downloads(from = &quot;2018-01-01&quot;, to = &quot;2020-04-01&quot;,packages = c(&quot;sp&quot;, &quot;sf&quot;, &quot;raster&quot;, &quot;tmap&quot;, &quot;mapview&quot;, &quot;leaflet&quot;, &quot;ggmap&quot;, &quot;stars&quot;)) monthly_stats &lt;- stats %&gt;% group_by(month=floor_date(date, &quot;month&quot;), package) %&gt;% summarize(amount=sum(count)) ggplot(monthly_stats, aes(x=month, y=amount, group = package, colour = package)) + geom_line(size=1.5) + scale_colour_brewer(palette=&quot;Set1&quot;) + ggtitle(&quot;R Monthly Spatial Package \\n Downloads since 2018&quot;) 1.4.6 Primary R spatial packages Figure 1.4: Moving on from sp sp was the core vector spatial data package in R for a number of years, and while still used and while many packages still depend on the package, we will make a clean break in this workshop and focus entirely on the new sf package for working with vector data. This portion of the workshop will focus primarily on the following core packages for working with spatial data in R: - sf - The core package for working with vector data in R - raster - Still the primary spatial package for working with raster data in R - mapview - this is a wrapper package for R leaflet package and I find simpler and more intuitive - ggolot and tmap - static plotting and thematic maping - dplyr - Not a spatial package, but sf is tidy-compliant and we will follow tidy workflows in this portion of the workshop for much or our examples The R Spatial Task View page provides current and comprehensive information on the ecosystem of R packages for working with spatial data - there are hundreds out there for specific tasks - well touch on several others besides core packages above this morning. 1.5 Quick examples Here is just a sampling of few quick spatial tasks. 1.5.1 Geocoding example with tmaptools using open street map Here well use the tmap package and tmaptools to geocode a named feature in OpenStreetMap import it into our R session as an sf feature. # uses OSM library(tmap) library(tmaptools) ## Warning: package &#39;tmaptools&#39; was built under R version 4.0.5 library(dplyr) tex_cap &lt;-tmaptools::geocode_OSM(&quot;Texas Capital USA&quot;, as.sf = TRUE) %&gt;% glimpse() ## Rows: 1 ## Columns: 9 ## $ query &lt;chr&gt; &quot;Texas Capital USA&quot; ## $ lat &lt;dbl&gt; 30.23948 ## $ lon &lt;dbl&gt; -97.79993 ## $ lat_min &lt;dbl&gt; 30.23897 ## $ lat_max &lt;dbl&gt; 30.23971 ## $ lon_min &lt;dbl&gt; -97.80003 ## $ lon_max &lt;dbl&gt; -97.79968 ## $ bbox &lt;POLYGON [°]&gt; POLYGON ((-97.80003 30.2389... ## $ point &lt;POINT [°]&gt; POINT (-97.79993 30.23948) 1.5.2 Run and examine code chunk above What is the double colon doing? What is the geocode_OSM function doing? Explain how the code runs together using the %&gt;% chaining operator What is glimpse? Is it useful compared to head function? 1.5.3 Answer It specifies using geocode_OSM from the tmaptools package. R gives namespace preference to packages in order loaded; some packages share function names; so its good practice to disambiguate your functions with the double-colon It is looking up a named feature in OpenStreetMap and returning the coordinates (bonus - well delve into more in next section - what coordinate reference system are coordinates in and how to you find out?) You would translate code using the &gt;%&gt; operator from: do this %&gt;% do that %&gt;% do that To do this then do that then do that Technically, its a transposed version of print - columns run down page, data across like rows - it additionally gives you the number of observations and variables, and the data type of each column bonus: how would you quickly learn more about glimpse from the console? 1.5.4 Choropleth map The excellent tigris package can be used to get census boundaries such as states and counties as vector sf objects in R library(sf) ## Warning: package &#39;sf&#39; was built under R version 4.0.5 ## Linking to GEOS 3.9.0, GDAL 3.2.1, PROJ 7.2.1 library(tigris) ## Warning: package &#39;tigris&#39; was built under R version 4.0.5 ## To enable ## caching of data, set `options(tigris_use_cache = TRUE)` in your R script or .Rprofile. counties &lt;- counties(&quot;Texas&quot;, cb = TRUE) counties$area &lt;- as.numeric(st_area(counties)) glimpse(counties) tm_shape(counties) + tm_polygons(&quot;area&quot;, style=&quot;quantile&quot;, title=&quot;Texas Counties Area&quot;) 1.5.5 Interactive mapping library(mapview) ## Warning: package &#39;mapview&#39; was built under R version 4.0.5 mapview(tex_cap, col=&quot;red&quot;, col.regions = &quot;red&quot;) + mapview(counties, alpha.regions = .1) "],["reading-in-spatial-data.html", "Chapter 2 Reading in Spatial Data 2.1 Reading in vector data", " Chapter 2 Reading in Spatial Data There are several ways we typically get spatial data into R: Load spatial files we have on our machine or from remote source Load spatial data that is part of an R package Grab data using API (often making use of particular R packages) Converting flat files with x,y data to spatial data Geocoding data (we saw example of this at beginning) For reading and writing vector and raster data in R, the three primary packages youll use are: sf or rgdal for vector formats such as ESRI Shapefiles, GeoJSON, and GPX - both packages use OGR, which is a library under the GDAL source tree,under the hood raster for raster formats such as GeoTIFF or ESRI or ASCII grid using GDAL under the hood We can quickly discover supported I/O vector formats either via sf or rgdal: library(knitr) library(sf) library(rgdal) print(paste0(&#39;There are &#39;,st_drivers(&quot;vector&quot;) %&gt;% nrow(), &#39; vector drivers available using st_read or read_sf&#39;)) ## [1] &quot;There are 89 vector drivers available using st_read or read_sf&quot; kable(head(ogrDrivers(),n=5)) name long_name write copy isVector AeronavFAA Aeronav FAA FALSE FALSE TRUE AmigoCloud AmigoCloud TRUE FALSE TRUE ARCGEN Arc/Info Generate FALSE FALSE TRUE AVCBin Arc/Info Binary Coverage FALSE FALSE TRUE AVCE00 Arc/Info E00 (ASCII) Coverage FALSE FALSE TRUE kable(head(st_drivers(what=&#39;vector&#39;),n=5)) name long_name write copy is_raster is_vector vsi ESRIC ESRIC Esri Compact Cache FALSE FALSE TRUE TRUE TRUE FITS FITS Flexible Image Transport System TRUE FALSE TRUE TRUE FALSE PCIDSK PCIDSK PCIDSK Database File TRUE FALSE TRUE TRUE TRUE netCDF netCDF Network Common Data Format TRUE TRUE TRUE TRUE FALSE PDS4 PDS4 NASA Planetary Data System 4 TRUE TRUE TRUE TRUE TRUE As well as I/O raster formats via sf: library(knitr) print(paste0(&#39;There are &#39;,st_drivers(what=&#39;raster&#39;) %&gt;% nrow(), &#39; raster drivers available&#39;)) ## [1] &quot;There are 149 raster drivers available&quot; kable(head(st_drivers(what=&#39;raster&#39;),n=5)) name long_name write copy is_raster is_vector vsi VRT VRT Virtual Raster TRUE TRUE TRUE FALSE TRUE DERIVED DERIVED Derived datasets using VRT pixel functions FALSE FALSE TRUE FALSE FALSE GTiff GTiff GeoTIFF TRUE TRUE TRUE FALSE TRUE COG COG Cloud optimized GeoTIFF generator FALSE TRUE TRUE FALSE TRUE NITF NITF National Imagery Transmission Format TRUE TRUE TRUE FALSE TRUE 2.1 Reading in vector data sf can be used to read numerous file types: Shapefiles Geodatabases Geopackages Geojson Spatial database files 2.1.1 Shapefiles Typically working with vector GIS data we work with ESRI shapefiles or geodatabases - here we have an example of how one would read in a shapefile using sf: # download.file(&quot;ftp://ftp.gis.oregon.gov/adminbound/citylim_2017.zip&quot;,&quot;citylim_2017.zip&quot;) # unzip(&quot;citylim_2017.zip&quot;, exdir = &quot;.&quot;) library(sf) citylims &lt;- st_read(&quot;citylim_2017.shp&quot;) ## Reading layer `citylim_2017&#39; from data source ## `C:\\Users\\mweber\\GitProjects\\R-User-Group-Spatial-Workshop-2021\\citylim_2017.shp&#39; ## using driver `ESRI Shapefile&#39; ## Simple feature collection with 241 features and 14 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: 234278.9 ymin: 94690.89 xmax: 2249460 ymax: 1644089 ## Projected CRS: NAD83 / Oregon GIC Lambert (ft) options(scipen=3) plot(citylims$geometry, axes=T, main=&#39;Oregon City Limits&#39;) # plot it! 2.1.2 st_read versus read_sf Above, I didnt pass any parameters to st_read - typically I would pass the parameters quiet=TRUE and stringsAsFactors=FALSE - why would this be a good practice in general? 2.1.3 Answer read_sf is an sf alternative to st_read (see this section 1.2.2). Try reading in citylims data above using read_sf and notice difference, and check out help(read_sf). read_sf and writesf` are simply aliases for st_read and st_write with modified default arguments. Big differences are: stringsAsFactors=FALSE quiet=TRUE as_tibble=TRUE 2.1.4 Geodatabases We use st_read or read_sf similarly for reading in an ESRI file geodatabase feature: # download.file(&quot;ftp://ftp.gis.oregon.gov/adminbound/OregonStateParks_20181010.zip&quot;, &quot;OregonStateParks.zip&quot;) # unzip(&quot;OregonStateParks.zip&quot;, exdir = &quot;.&quot;) library(ggplot2) fgdb = &quot;OregonStateParks_20181010.gdb&quot; # List all feature classes in a file geodatabase st_layers(fgdb) ## Driver: OpenFileGDB ## Available layers: ## layer_name geometry_type features fields ## 1 LO_PARKS Multi Polygon 431 15 # Read the feature class parks &lt;- st_read(dsn=fgdb,layer=&quot;LO_PARKS&quot;) ## Reading layer `LO_PARKS&#39; from data source ## `C:\\Users\\mweber\\GitProjects\\R-User-Group-Spatial-Workshop-2021\\OregonStateParks_20181010.gdb&#39; ## using driver `OpenFileGDB&#39; ## Simple feature collection with 431 features and 15 fields ## Geometry type: GEOMETRY ## Dimension: XY ## Bounding box: xmin: 222821.4 ymin: 88699.71 xmax: 2243413 ymax: 1655108 ## Projected CRS: NAD83(2011) / Oregon GIC Lambert (ft) ggplot(parks) + geom_sf() 2.1.5 Geopackages Another spatial file format is the geopackage. Lets try a quick read and write of geopackage data. First well read in a geopackage using data that comes with sf using dplyr syntax just to show something a bit different and use read_sf as an alternative to st_read. You may want to try writing the data back out as a geopackage as well. Quick question: What are a couple advantages of geopackages over shapefiles? library(dplyr) nc &lt;- system.file(&quot;gpkg/nc.gpkg&quot;, package=&quot;sf&quot;) %&gt;% read_sf() # reads in glimpse(nc) ## Rows: 100 ## Columns: 15 ## $ AREA &lt;dbl&gt; 0.114, 0.061, 0.143, 0.070, 0.153, 0.097, 0.062, 0.091, 0.11~ ## $ PERIMETER &lt;dbl&gt; 1.442, 1.231, 1.630, 2.968, 2.206, 1.670, 1.547, 1.284, 1.42~ ## $ CNTY_ &lt;dbl&gt; 1825, 1827, 1828, 1831, 1832, 1833, 1834, 1835, 1836, 1837, ~ ## $ CNTY_ID &lt;dbl&gt; 1825, 1827, 1828, 1831, 1832, 1833, 1834, 1835, 1836, 1837, ~ ## $ NAME &lt;chr&gt; &quot;Ashe&quot;, &quot;Alleghany&quot;, &quot;Surry&quot;, &quot;Currituck&quot;, &quot;Northampton&quot;, &quot;H~ ## $ FIPS &lt;chr&gt; &quot;37009&quot;, &quot;37005&quot;, &quot;37171&quot;, &quot;37053&quot;, &quot;37131&quot;, &quot;37091&quot;, &quot;37029~ ## $ FIPSNO &lt;dbl&gt; 37009, 37005, 37171, 37053, 37131, 37091, 37029, 37073, 3718~ ## $ CRESS_ID &lt;int&gt; 5, 3, 86, 27, 66, 46, 15, 37, 93, 85, 17, 79, 39, 73, 91, 42~ ## $ BIR74 &lt;dbl&gt; 1091, 487, 3188, 508, 1421, 1452, 286, 420, 968, 1612, 1035,~ ## $ SID74 &lt;dbl&gt; 1, 0, 5, 1, 9, 7, 0, 0, 4, 1, 2, 16, 4, 4, 4, 18, 3, 4, 1, 1~ ## $ NWBIR74 &lt;dbl&gt; 10, 10, 208, 123, 1066, 954, 115, 254, 748, 160, 550, 1243, ~ ## $ BIR79 &lt;dbl&gt; 1364, 542, 3616, 830, 1606, 1838, 350, 594, 1190, 2038, 1253~ ## $ SID79 &lt;dbl&gt; 0, 3, 6, 2, 3, 5, 2, 2, 2, 5, 2, 5, 4, 4, 6, 17, 4, 7, 1, 0,~ ## $ NWBIR79 &lt;dbl&gt; 19, 12, 260, 145, 1197, 1237, 139, 371, 844, 176, 597, 1369,~ ## $ geom &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((-81.47276 3..., MULTIPOLYGON ((~ 2.1.6 Open spatial data sources There is a wealth of open spatial data accessible online now via static URLs or APIs - a few examples include Data.gov, NASA SECAC Portal, Natural Earth, UNEP GEOdata, and countless others listed here at Free GIS Data 2.1.7 Spatial data from R packages There are also a number of R packages written specifically to provide access to geospatial data - below are a few and well step through some examples of pulling in data using some of these packages. Table 2.1: Example R packages for spatial data retrieval. Package name Description USABoundaries Provide historic and contemporary boundaries of the US tigris Download and use US Census TIGER/Line Shapefiles in R tidycensus Uses Census American Community API to return tidyverse and optionally sf ready data frames FedData Functions for downloading geospatial data from several federal sources elevatr Access elevation data from various APIs (by Jeff Hollister) getlandsat Provides access to Landsat 8 data. osmdata Download and import of OpenStreetMap data. raster The getData() function downloads and imports administrative country, SRTM/ASTER elevation, WorldClim data. rnaturalearth Functions to download Natural Earth vector and raster data, including world country borders. rnoaa An R interface to National Oceanic and Atmospheric Administration (NOAA) climate data. rWBclimate An access to the World Bank climate data. Below is an example of pulling in US states using the rnaturalearth package - note that the default is to pull in data as sp objects and we coerce to sf. Also take a look at the chained operation using dplyr. Try changing the filter or a parameter in ggplot. library(rnaturalearth) library(dplyr) library(ggplot2) states &lt;- ne_states(country = &#39;United States of America&#39;) states_sf &lt;- st_as_sf(states) states_sf %&gt;% dplyr::filter(!name %in% c(&#39;Hawaii&#39;,&#39;Alaska&#39;) &amp; !is.na(name)) %&gt;% ggplot + geom_sf() 2.1.8 Read in raster data Here we use the getData function in the raster package to download elevation into a RasterLayer and grab administrative boundaries from a database of global administrative boundaries - warning: sometimes getData function has trouble accessing the server and download can be a bit slow. Here we see as well how we can use vector spataio polygon data to crop raster data. library(raster) US &lt;- getData(&quot;GADM&quot;,country=&quot;USA&quot;,level=2) Benton &lt;- US[US$NAME_1==&#39;Oregon&#39; &amp; US$NAME_2==&#39;Benton&#39;,] elev &lt;- getData(&#39;SRTM&#39;, lon=-123, lat=44) elev &lt;- crop(elev, Benton) elev &lt;- mask(elev, Benton) plot(Benton, main=&quot;Elevation (m) in Benton County, Oregon&quot;, axes=T) plot(elev, add=TRUE) plot(Benton, add=TRUE) 2.1.9 Read in OpenStreetMap data The osmdata package is a fantastic resource for leveraging the OpenStreetMap (OSM) database. library(osmdata) library(mapview) footway &lt;- opq(bbox = &quot;corvallis oregon&quot;) %&gt;% add_osm_feature(key = &quot;highway&quot;, value = &quot;footway&quot;) %&gt;% osmdata_sf() footway &lt;- footway$osm_lines mapview(footway$geometry) library(osmdata) library(mapview) rstrnts &lt;- opq(bbox = &quot;corvallis oregon&quot;) %&gt;% add_osm_feature(key = &quot;amenity&quot;, value = &quot;restaurant&quot;) %&gt;% osmdata_sf() rstrnts &lt;- rstrnts$osm_points mapview(rstrnts$geometry) We often have flat files, locally on our machine or accessed elsewhere, that have coordinate information which we would like to make spatial: library(devtools) library(readr) library(ggplot2) # install_github(&quot;mhweber/awra2020spatial&quot;, force=TRUE) library(awra2020spatial) gages = read_csv(system.file(&quot;extdata/Gages_flowdata.csv&quot;, package = &quot;awra2020spatial&quot;)) gages_sf &lt;- gages %&gt;% st_as_sf(coords = c(&quot;LON_SITE&quot;, &quot;LAT_SITE&quot;), crs = 4269, remove = FALSE) %&gt;% dplyr::select(STATION_NM,LON_SITE, LAT_SITE) ggplot() + geom_sf(data=gages_sf) "],["coordinate-reference-systems.html", "Chapter 3 Coordinate reference systems 3.1 Lesson Objectives", " Chapter 3 Coordinate reference systems 3.1 Lesson Objectives Describe and understand a CRS in R and components of a CRS A CRS is made up of several components: Coordinate system: The x,y grid that defines where your data lies in space Horizontal and vertical units: The units describing grid along the x,y and possibly z axes Datum: The modeled version of the shape of the earth Projection details: If projected, the mathematical equation used to flatten objects from round surface (earth) to flat surface (paper or screen) Figure 3.1: Source: https://mgimond.github.io/Spatial/coordinate-systems.html The earth is a sphere, but more precisely, an ellipsoid, which is defined by two radii: - semi-major axis (equatorial radius) - semi-minor axis (polar radius) We know with precision that the measure of these two are 6,378,137 meters and 6,356,752 meters respectively. More precisely that an ellipsoid, though, we know that earth is a geoid - it is not perfectly smooth - and modelling the the undulations due to changes in gravitational pull for different locations is crucial to accuracy in a GIS. This is where a datum comes in - we match the geoid to the ellipsoid to best match local conditions. We have many datums to choose from based on location of interest - in the US we would typically choose NAD83 3.1.1 Why you need to know about CRS working with spatial data in R: library(awra2020spatial) library(readr) library(sf) data(pnw) gages = read_csv(system.file(&quot;extdata/Gages_flowdata.csv&quot;, package = &quot;awra2020spatial&quot;)) gages_sf &lt;- gages %&gt;% st_as_sf(coords = c(&quot;LON_SITE&quot;, &quot;LAT_SITE&quot;), crs = 4269, remove = FALSE) %&gt;% dplyr::select(STATION_NM,LON_SITE, LAT_SITE) # Awesome, let&#39;s plot our gage data and state boundaries! plot(pnw$geometry, axes=TRUE) plot(gages_sf$geometry, col=&#39;red&#39;, add=TRUE) # um, what? There is no on-the-fly projection in R - you need to make sure you specify the CRS of your objects, and CRS needs to match for any spatial operations or youll get an error spatialreference.org is your friend in R - chances are you will use it frequently working with spatial data in R. Useful rgdal package functions: projInfo(type=datum) projInfo(type=ellps) projInfo(type=proj) 3.1.2 Changes to CRS recently in R in sf Its important to understand recent changes in handling of crs in sf Prior to sf 0.9, crs were represented as lists with two components: - epsg (European Petroleum Survey Group ) code, which could be NA - proj4string - a projection string library(sf) # Linking to GEOS 3.8.0, GDAL 3.0.2, PROJ 6.2.1 st_crs(4326) # Coordinate Reference System: # EPSG: 4326 # proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot; Now, however, sf represents crs as lists with two different components: - input - wkt library(sf) ## Linking to GEOS 3.8.0, GDAL 3.0.2, PROJ 6.2.1 (x = st_crs(4326)) ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;World&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] You can still get the proj4string or epsg value by: x$epsg ## [1] 4326 x$proj4string ## [1] &quot;+proj=longlat +datum=WGS84 +no_defs&quot; 3.1.3 Projected coordinate systems Typically we want to work with data that is projected. Projected coordinate systems (which are based on Cartesian coordinates) have: an origin, an x axis, a y axis, and a linear unit of measure. Going from geographic coordinates to a projected coordinate reference systems requires mathematical transformations. Four spatial properties of projected coordinate systems that are subject to distortion are: shape, area, distance and direction. A map that preserves shape is called conformal; one that preserves area is called equal-area; one that preserves distance is called equidistant; and one that preserves direction is called azimuthal (from https://mgimond.github.io/Spatial/coordinate-systems.html. The takeaway from all this is you need to be aware of the crs for your objects in R, make sure they are projected if appropriate and in a projection that optimizes properties you are interested in, and objects you are analyzing or mapping together need to be in same crs. Going back to our original example, we can transform crs of objects to work with them together: library(ggplot2) # Check our coordinate reference systems st_crs(gages_sf) ## Coordinate Reference System: ## User input: EPSG:4269 ## wkt: ## GEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;Geodesy.&quot;], ## AREA[&quot;North America - onshore and offshore: Canada - Alberta; British Columbia; Manitoba; New Brunswick; Newfoundland and Labrador; Northwest Territories; Nova Scotia; Nunavut; Ontario; Prince Edward Island; Quebec; Saskatchewan; Yukon. Puerto Rico. United States (USA) - Alabama; Alaska; Arizona; Arkansas; California; Colorado; Connecticut; Delaware; Florida; Georgia; Hawaii; Idaho; Illinois; Indiana; Iowa; Kansas; Kentucky; Louisiana; Maine; Maryland; Massachusetts; Michigan; Minnesota; Mississippi; Missouri; Montana; Nebraska; Nevada; New Hampshire; New Jersey; New Mexico; New York; North Carolina; North Dakota; Ohio; Oklahoma; Oregon; Pennsylvania; Rhode Island; South Carolina; South Dakota; Tennessee; Texas; Utah; Vermont; Virginia; Washington; West Virginia; Wisconsin; Wyoming. US Virgin Islands. British Virgin Islands.&quot;], ## BBOX[14.92,167.65,86.46,-47.74]], ## ID[&quot;EPSG&quot;,4269]] st_crs(pnw) ## Coordinate Reference System: ## User input: +proj=aea +lat_1=41 +lat_2=47 +lat_0=44 +lon_0=-120 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs ## wkt: ## PROJCRS[&quot;unknown&quot;, ## BASEGEOGCRS[&quot;unknown&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]], ## ID[&quot;EPSG&quot;,6269]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8901]]], ## CONVERSION[&quot;unknown&quot;, ## METHOD[&quot;Albers Equal Area&quot;, ## ID[&quot;EPSG&quot;,9822]], ## PARAMETER[&quot;Latitude of false origin&quot;,44, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8821]], ## PARAMETER[&quot;Longitude of false origin&quot;,-120, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8822]], ## PARAMETER[&quot;Latitude of 1st standard parallel&quot;,41, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8823]], ## PARAMETER[&quot;Latitude of 2nd standard parallel&quot;,47, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8824]], ## PARAMETER[&quot;Easting at false origin&quot;,0, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8826]], ## PARAMETER[&quot;Northing at false origin&quot;,0, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8827]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1, ## ID[&quot;EPSG&quot;,9001]]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1, ## ID[&quot;EPSG&quot;,9001]]]] # Are they equal? st_crs(gages_sf)==st_crs(pnw) ## [1] FALSE # transform one to the other gages_sf &lt;- st_transform(gages_sf, st_crs(pnw)) ggplot() + geom_sf(data=gages_sf, color=&quot;blue&quot;) + geom_sf(data=pnw, color=&quot;black&quot;, fill=NA) + labs(title=&quot;USGS Stream Gages in the Pacific Northwest&quot;) + theme_bw() "],["vector-data-with-sf.html", "Chapter 4 Vector data with sf", " Chapter 4 Vector data with sf Figure 4.1: Sticky geometry with sf sf makes use of a couple key libraries that are the foundation for most open source geospatial software Figure 4.2: Source: https://www.r-spatial.org/r/2020/03/17/wkt.html sf is an implementation of Simple features, an open standard developed and endorsed by the Open Geospatial Consortium (OGC). Simple Features is a hierarchical data model that represents a wide range of geometry types - it includes all common vector geometry types (but does not include raster) and even allows geometry collections, which can have multiple geometry types in a single object. From the first sf package vignette we see: knitr::include_graphics(&quot;images/sf_objects.png&quot;) The big difference between sf and sp is that sf uses S3 classes rather than S4 as sp does. Simple features are simple data.frame objects that have a geometry list-column. The simple feature model will be familiar to those who use PostGIS, MySQL Spatial Extensions, Oracle Spatial, the OGR component of the GDAL library, GeoJSON and GeoPandas in Python. Simple features are represented with Well-Known text - WKT - and well-known binary formats. Just as in PostGIS, all functions and methods in sf are prefixed with st_, which stands for spatial and temporal. An advantage of this prefixing is all commands are easy to find with command-line completion in sf. There is extensive documentation, blog posts and vignettes available for sf here: Simple Features for R. Additionally, see r-spatial blog which has numerous announcements, discussion pieces and tutorials on spatial work in R focused. A very handy page, if youre already familiar with the sp ecosystem, is the Migrating page on the sf GitHub wiki. Heres a quick synopsis of available methods in sf: library(sf) methods(class = &#39;sf&#39;) ## [1] $&lt;- [ [[&lt;- ## [4] aggregate anti_join arrange ## [7] as.data.frame cbind coerce ## [10] dbDataType dbWriteTable distinct ## [13] dplyr_reconstruct extent extract ## [16] filter full_join group_by ## [19] group_split identify initialize ## [22] inner_join left_join mapView ## [25] mask merge mutate ## [28] plot print raster ## [31] rasterize rbind rename ## [34] right_join rowwise sample_frac ## [37] sample_n select semi_join ## [40] show slice slotsFromS3 ## [43] st_agr st_agr&lt;- st_area ## [46] st_as_s2 st_as_sf st_bbox ## [49] st_boundary st_buffer st_cast ## [52] st_centroid st_collection_extract st_convex_hull ## [55] st_coordinates st_crop st_crs ## [58] st_crs&lt;- st_difference st_filter ## [61] st_geometry st_geometry&lt;- st_inscribed_circle ## [64] st_interpolate_aw st_intersection st_intersects ## [67] st_is st_is_valid st_join ## [70] st_line_merge st_m_range st_make_valid ## [73] st_nearest_points st_node st_normalize ## [76] st_point_on_surface st_polygonize st_precision ## [79] st_reverse st_sample st_segmentize ## [82] st_set_precision st_shift_longitude st_simplify ## [85] st_snap st_sym_difference st_transform ## [88] st_triangulate st_union st_voronoi ## [91] st_wrap_dateline st_write st_z_range ## [94] st_zm summarise transform ## [97] transmute ungroup ## see &#39;?methods&#39; for accessing help and source code Lets start exploring sf using some data included in the awra2020spatial package. library(awra2020spatial) data(bike_paths) head(bike_paths[,c(&#39;ROUTE_CODE&#39;,&#39;ROUTE_NAME&#39;,&#39;geoms&#39;)]) ## Simple feature collection with 6 features and 2 fields ## Geometry type: MULTILINESTRING ## Dimension: XY ## Bounding box: xmin: -97.75811 ymin: 30.26214 xmax: -97.75198 ymax: 30.28477 ## Geodetic CRS: WGS 84 ## ROUTE_CODE ROUTE_NAME geoms ## 1 43.0023 LAMAR BLVD N MULTILINESTRING ((-97.75198... ## 2 43.0023 LAMAR BLVD N MULTILINESTRING ((-97.75198... ## 3 43.0028 LAMAR BLVD S MULTILINESTRING ((-97.75711... ## 4 43.0028 LAMAR BLVD S MULTILINESTRING ((-97.75711... ## 5 43.0028 LAMAR BLVD S MULTILINESTRING ((-97.75775... ## 6 43.0028 LAMAR BLVD S MULTILINESTRING ((-97.75775... Lets break down what we just saw in bike paths, which is bike paths in Austin - from the first sf package vignette: knitr::include_graphics(&quot;images/sf_structure.png&quot;) We can see: in green a simple feature: a single record, or data.frame row, consisting of attributes and geometry in blue a single simple feature geometry (an object of class sfg) in red a simple feature list-column (an object of class sfc, which is a column in the data.frame) The sfc, our geometry list-column, is presented as well-known text, in the form of (for polygon data): Multipolygon(polygon1, polygon2) polygon1 might have 1 or more holes, and itself could be represented as (poly1, hole1, hole2). Each polygon and its holes are held together by a set of parentheses, so: Multipolygon(((list of coordinates))) indicates the exterior ring coordinates, going counter-clockwise in direction, without holes, of the first polygon. Generic plotting works on sf objects - take a minute to play with ploting the bike paths data frame - why do we specify $geometry in the plot call? plot(bike_paths$geoms, axes=T) 4.0.1 Units in sf The crs in sf encodes the units of measure in information relating to spatial units of features - this can be both handy and very confusing for those new to it. Consider the following: (sum(st_length(bike_paths))) ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## 3458778 [m] We can set units if we do manipulations as well using the units package units::set_units(sum(st_length(bike_paths)),km) ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## 3458.778 [km] If we need to use the value elsewhere get rid of units as.numeric(sum(st_length(bike_paths))) ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## old-style crs object detected; please recreate object with a recent sf::st_crs() ## [1] 3458778 "],["raster-data.html", "Chapter 5 Raster data", " Chapter 5 Raster data Support for gridded data in R in recent year has been best implemented with the raster package by Robert Hijmans. The raster package allows you to: read and write almost any commonly used raster data format using rgdal perform typical raster processing operations such as resampling, projecting, filtering, raster math, etc. work with files on disk that are too big to read into memory in R run operations quickly since the package relies on back-end C code The home page for the raster package has links to several well-written vignettes and documentation for the package. The raster package uses three classes / types of objects to represent raster data - RasterLayer, RasterStack, and RasterBrick - these are all S4 new style classes in R, just like sp classes. There are new developments in raster world in R worth noting - a new package called stars (spatiotemporal tidy arrays with R) has been developed through an R-Consortium funded project to handle rasters in a way that is both sf and pipe-based workflow friendly. Additionally, Robert Hijmans has a new in development package called terra as a replacement package for raster. To familiarize ourselves with the raster package, lets create an empty RasterLayer object - in order to do this we have to: * define the matrix (rows and columns) * define the spatial bounding box * provide values to the cells Note that typically we would be reading raster data in from a file rather than creating a raster from scratch. Run through code steps below to familiarize yourself with contsructing a RasterLayer from scratch. library(raster) r &lt;- raster(ncol=10, nrow = 10, xmx=-116,xmn=-126,ymn=42,ymx=46) str(r) ## Formal class &#39;RasterLayer&#39; [package &quot;raster&quot;] with 12 slots ## ..@ file :Formal class &#39;.RasterFile&#39; [package &quot;raster&quot;] with 13 slots ## .. .. ..@ name : chr &quot;&quot; ## .. .. ..@ datanotation: chr &quot;FLT4S&quot; ## .. .. ..@ byteorder : chr &quot;little&quot; ## .. .. ..@ nodatavalue : num -Inf ## .. .. ..@ NAchanged : logi FALSE ## .. .. ..@ nbands : int 1 ## .. .. ..@ bandorder : chr &quot;BIL&quot; ## .. .. ..@ offset : int 0 ## .. .. ..@ toptobottom : logi TRUE ## .. .. ..@ blockrows : int 0 ## .. .. ..@ blockcols : int 0 ## .. .. ..@ driver : chr &quot;&quot; ## .. .. ..@ open : logi FALSE ## ..@ data :Formal class &#39;.SingleLayerData&#39; [package &quot;raster&quot;] with 13 slots ## .. .. ..@ values : logi(0) ## .. .. ..@ offset : num 0 ## .. .. ..@ gain : num 1 ## .. .. ..@ inmemory : logi FALSE ## .. .. ..@ fromdisk : logi FALSE ## .. .. ..@ isfactor : logi FALSE ## .. .. ..@ attributes: list() ## .. .. ..@ haveminmax: logi FALSE ## .. .. ..@ min : num Inf ## .. .. ..@ max : num -Inf ## .. .. ..@ band : int 1 ## .. .. ..@ unit : chr &quot;&quot; ## .. .. ..@ names : chr &quot;&quot; ## ..@ legend :Formal class &#39;.RasterLegend&#39; [package &quot;raster&quot;] with 5 slots ## .. .. ..@ type : chr(0) ## .. .. ..@ values : logi(0) ## .. .. ..@ color : logi(0) ## .. .. ..@ names : logi(0) ## .. .. ..@ colortable: logi(0) ## ..@ title : chr(0) ## ..@ extent :Formal class &#39;Extent&#39; [package &quot;raster&quot;] with 4 slots ## .. .. ..@ xmin: num -126 ## .. .. ..@ xmax: num -116 ## .. .. ..@ ymin: num 42 ## .. .. ..@ ymax: num 46 ## ..@ rotated : logi FALSE ## ..@ rotation:Formal class &#39;.Rotation&#39; [package &quot;raster&quot;] with 2 slots ## .. .. ..@ geotrans: num(0) ## .. .. ..@ transfun:function () ## ..@ ncols : int 10 ## ..@ nrows : int 10 ## ..@ crs :Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr &quot;+proj=longlat +datum=WGS84 +no_defs&quot; ## ..@ history : list() ## ..@ z : list() raster uses a S4 slot structure with a RasterLayer object. Simply typing the name of the RasterLayer gives a summary of the object at the console. r ## class : RasterLayer ## dimensions : 10, 10, 100 (nrow, ncol, ncell) ## resolution : 1, 0.4 (x, y) ## extent : -126, -116, 42, 46 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs 5.0.1 Exploring raster objects what is the minimal data required to define a RasterLayer? What is odd here about the CRS? How do we pull out just the CRS for our r rasterLayer? Building on this, what is the code to pull out just our xmin value in our extent, or bounding box? 5.0.2 Answer number columns, number rows, and extent - though the raster package will use defaults if values arent provided We didnt provide one - raster uses default crs of WGS84 if you dont provide a crs r@crs ## CRS arguments: +proj=longlat +datum=WGS84 +no_defs # or crs(r) ## CRS arguments: +proj=longlat +datum=WGS84 +no_defs slotNames(r) ## [1] &quot;file&quot; &quot;data&quot; &quot;legend&quot; &quot;title&quot; &quot;extent&quot; &quot;rotated&quot; ## [7] &quot;rotation&quot; &quot;ncols&quot; &quot;nrows&quot; &quot;crs&quot; &quot;history&quot; &quot;z&quot; r@extent[1] ## [1] -126 # there are slots w/in slots too slotNames(r@extent) ## [1] &quot;xmin&quot; &quot;xmax&quot; &quot;ymin&quot; &quot;ymax&quot; r@extent@xmin ## [1] -126 # There&#39;s always a couple ways to do same thing in R... extent(r)[1] ## [1] -126 5.0.3 Manipulating raster objects So far we just have a container with no values (try plotting what we have so far) - lets provide values to the cells using the runif function to derive random values from the uniform distribution r[] &lt;- runif(n=ncell(r)) r ## class : RasterLayer ## dimensions : 10, 10, 100 (nrow, ncol, ncell) ## resolution : 1, 0.4 (x, y) ## extent : -126, -116, 42, 46 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs ## source : memory ## names : layer ## values : 0.003632618, 0.9956636 (min, max) Notice the different output now when typing r? An important point to make here is that objects in the raster package can be either in memory or on disk - not the value for our RasterLayer r of data source. If this were a large raster on disk, the value would be the path to the file on disk. We can test this as well using methods in raster (and test if the raster has values too): inMemory(r) ## [1] TRUE fromDisk(r) ## [1] FALSE hasValues(r) ## [1] TRUE We can plot now as well with base R plot: plot(r) We can also overwrite the cell values for our raster: values(r) &lt;- 1:ncell(r) values(r) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ## [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 ## [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 ## [91] 91 92 93 94 95 96 97 98 99 100 You can access raster values via direct indexing or line, column indexing - take a minute to see how this works using raster r we just created - the syntax is: r[i] r[line, column] How is raster data storage unlike a matrix in R? You can create a matrix with same dimensions and values and compare if you want: m &lt;- matrix (1:100, nrow=10, ncol=10) m[1,2] ## [1] 11 r[1,2] ## [1] 2 5.0.4 RasterBricks and Rasterstacks RasterBrick and RasterStack are the two additional classes in raster and handle multiple raster layers. They differ from each other in how they handle multiple layers, file formats they support, their representation and their processing speed. A RasterBrick typically is a single multi-layer file such as a multispectral image. A RasterStack can virtually connect several RasterLayer objects in memory and allows pixel-based calculations on separate raster layers, while a RasterBrick has to refer to a single multi-layer file or multi-layer object. Note that methods that operate on either a RasterStack or RasterBrick usually return a RasterBrick, and processing will be mor efficient on a RasterBrick object. Its easy to manipulate our RasterLayer to make a couple new layers, and then stack layers: r2 &lt;- r * 50 r3 &lt;- sqrt(r * 5) s &lt;- stack(r, r2, r3) s ## class : RasterStack ## dimensions : 10, 10, 100, 3 (nrow, ncol, ncell, nlayers) ## resolution : 1, 0.4 (x, y) ## extent : -126, -116, 42, 46 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs ## names : layer.1, layer.2, layer.3 ## min values : 1.000000, 50.000000, 2.236068 ## max values : 100.00000, 5000.00000, 22.36068 plot(s) Same process for generating a raster brick (here I make layers and create a RasterBrick in same step): b &lt;- brick(x=c(r, r * 50, sqrt(r * 5))) b ## class : RasterBrick ## dimensions : 10, 10, 100, 3 (nrow, ncol, ncell, nlayers) ## resolution : 1, 0.4 (x, y) ## extent : -126, -116, 42, 46 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs ## source : memory ## names : layer.1, layer.2, layer.3 ## min values : 1.000000, 50.000000, 2.236068 ## max values : 100.00000, 5000.00000, 22.36068 "],["geoprocessing.html", "Chapter 6 Geoprocessing 6.1 Lesson Goals 6.2 Example one 6.3 Example two 6.4 Example Three", " Chapter 6 Geoprocessing 6.1 Lesson Goals A quick look at a couple typical topological operations (spatial subsetting, spatial joins, dissolve) using sf 6.2 Example one 6.2.1 Spatial Subsetting Lets look at the bike paths and parks data in the awra2020spatial package. A typical spatial question we might ask of our data is what trails go through parks in town? A great feature of sf is it supports spatial indexing: library(sf) library(awra2020spatial) data(parks) data(bike_paths) plot(bike_paths$geoms, col=&#39;green&#39;, axes=T) plot(parks$geoms, col=&#39;blue&#39;, add=T) paths_in_parks &lt;- bike_paths[parks,] plot(paths_in_parks$geoms, col=&#39;red&#39;, lwd = 2, add=T) title(main=&#39;Bike Paths in Parks in Austin&#39;) 6.3 Example two 6.3.1 Spatial Join First well use chained operations to select just a couple columns from both bike_paths and parks, and then well do a spatial join operation in sf. Note again, when we do a select on just attribute column, the geometry column remains - geometry is sticky in sf! library(dplyr) bike_paths &lt;- bike_paths %&gt;% dplyr::select(ROUTE_NAME) parks &lt;- parks %&gt;% dplyr::select(LOCATION_NAME, ZIPCODE,PARK_TYPE) parks_bike_paths &lt;- st_join(parks, bike_paths) # st_intersects is the default glimpse(parks_bike_paths) ## Rows: 744 ## Columns: 5 ## $ LOCATION_NAME &lt;chr&gt; &quot;Stratford Overlook Greenbelt&quot;, &quot;Highland Neighborhood P~ ## $ ZIPCODE &lt;chr&gt; &quot;78746&quot;, &quot;78752&quot;, &quot;78703&quot;, &quot;78753&quot;, &quot;78724&quot;, &quot;78702&quot;, &quot;7~ ## $ PARK_TYPE &lt;chr&gt; &quot;Greenbelt&quot;, &quot;Neighborhood&quot;, &quot;Pocket&quot;, &quot;Neighborhood&quot;, &quot;~ ## $ ROUTE_NAME &lt;chr&gt; NA, NA, NA, NA, NA, NA, &quot;TOWN LAKE HIKE &amp; BIKE TRAIL&quot;, &quot;~ ## $ geoms &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((-97.78802 3..., MULTIPOLYGO~ 6.4 Example Three 6.4.1 Dissolve We can perform a spatial dissolve in sf using dplyr group_by and summarize functions with an sf object! Note that we could pull down tidycensus at tract level, but instead we want to look at running a dissolve to get from block group to tract level library(ggplot2) parks$AREA &lt;- st_area(parks) parks_zip &lt;- parks %&gt;% group_by(ZIPCODE) %&gt;% summarise(AREA = sum(AREA)) %&gt;% ggplot() + geom_sf(aes(fill=(ZIPCODE))) + ggtitle(&quot;Austin Parks by Zip Code&quot;) + theme_bw() parks_zip "],["visualizing-spatial-data.html", "Chapter 7 Visualizing Spatial Data 7.1 Lesson Goals", " Chapter 7 Visualizing Spatial Data 7.1 Lesson Goals Explore a couple mapping libraries in R R is fantastic for making publication quality static maps, and for generating repetitive graphics through scripts, and weve shown the use of base plotting and using ggplot for making maps already. There are also a number of packages in R that link R code to plotting libraries developed in Javascript (or other languages) for interactive plotting and web integration. 7.1.1 Chorpleths with tmap Load tidycensus - youll need to set your Census API key. A key can be obtained from here. Here we make a choropleth map of median household income in Travis county in Texas. library(sf) library(tidycensus) ## Warning: package &#39;tidycensus&#39; was built under R version 4.0.5 # census_api_key(&quot;YOUR API KEY GOES HERE&quot;) library(tidycensus) library(tmap) options(tigris_use_cache = FALSE) austin_tracts &lt;- get_acs(state = &#39;TX&#39;, county = &#39;Travis&#39;, geography = &quot;tract&quot;, variables = &quot;B19013_001&quot;, geometry = TRUE) tm_shape(austin_tracts) + tm_polygons(&quot;estimate&quot;) 7.1.2 Leaflet Leaflet is an extremely popular open-source javascript library for interactive web mapping, and the leaflet R package allows R users to create Leaflet maps from R. Leaflet can plot sf or sp objects, or x / y coordinates, and can plot points, lines or polygons. There are a number of base layers you can choose from. Its worth spending some time exploring the excellent Leaflet for R site. Here we make the simplest of leaflet maps: library(leaflet) m &lt;- leaflet() %&gt;% addTiles() %&gt;% # Add default OpenStreetMap map tiles addMarkers(lng=-123.26720, lat=44.5810, popup=&quot;Here&#39;s my house&quot;) m # Print the map 7.1.3 mapview Mapview is a package designed for quick and easy interactive visualizations of spatial data - it makes use of leaflet but simplifies mapping functions compared to the leaflet package. Its easy to layer features with mapview - you can supply a list of objects to mapview or use + syntax as with ggplot. library(awra2020spatial) library(mapview) data(bike_paths) data(parks) mapview(bike_paths) + parks "],["references.html", "References", " References 7.1.4 R Spatial Resources R Spatial - Spatial Data Science with R Geocomputation with R R Spatial Task View Modern Geospatial Data Analysis with R by Zev Ross Spatial Data Science - Pebesma and Bivand Spatial Data Science Course- Prof. Adam Wilson Introduction to Mapping and Spatial Analysis with R R Spatial Workshop for EPA R User Group Intro to GIS and Spatial Analysis by Manuel Gimond FOSS4G2019 R for Geospatial Processing An Introduction to Spatial Analysis and Mapping in R Earth Analytics Spatial Data in R 7.1.5 R Vector Processing / Simple Features Resources Simple Features for R Spatial Data in R: New Directions sp-sf Migration An Exploration of Simple Features for R Simple Features: Building Spatial Data Pipelines in R Tidy spatial data in R: using dplyr, tidyr, and ggplot2 with sf 7.1.6 R Raster Resources Wageningen University Intro to Raster Wageningen University Advanced Raster Analysis The Visual Raster Cheat Sheet GitHub Repo Rastervis stars - spatiotemporal arrays 7.1.7 R Mapping Resources mapview Leaflet for R tmap Zev Ross Creating beautiful demographic maps in R with the tidycensus and tmap packages Geocomputation with R: Making maps with R Ryan Peek: Mapping in R 7.1.8 General R Resources Google R Style Guide Advanced R by Hadley Wickham "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
